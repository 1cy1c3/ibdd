/**
 * @file Manager.hpp
 * @author Rune Krauss
 *
 * @brief The manager holds operations for manipulating BDDs such as creating variables or synthesizing.
 * In this respect, the computed and unique tables are also used to increase performance.
 * This applies in addition to the synthesis other algorithms such as the existential quantification
 * (@see BDDNode#exist). Furthermore, the memory for the respective tables is allocated and the
 * garbage collection (@see clear) is managed. Nodes can also be visualized.
 */
#ifndef Manager_hpp
#define Manager_hpp

#include <cassert>
#include "UTable.hpp"
#include "CTable.hpp"
#include "TableKey.hpp"
#include "DDNode.hpp"

/**
 * This class performs all administrative tasks of this library. These include synthesis, i. e. BDDs
 * are generated by combining several BDDs whereby - to increase performance or reduce memory usage -
 * further techniques such as complement edges and standard triplets (@see standardize) are used.
 * The standardization leads, for example, to the fact that redundant calculations regarding the
 * computed table can be avoided. It can also be used to create variables (@see createVariable) which
 * can be used for nodes.
 */
class Manager
{
    typedef UTable<TableKey, DDNode*> UTable;
    typedef CTable<TableKey, size_t> CTable;
private:
    /**
     * Represents the unique table (@see UTable) to store nodes in it or to ensure canonicity.
     */
    UTable uTable;
    
    /**
     * Describes the computed table (@see CTable) to reduce the computational effort or storage
     * space of the synthesis (@see ite) whereby already calculated results are stored there.
     */
    CTable cTable;
    
    /**
     * Contains the supported or reserved variables that can be used within the synthesis.
     */
    std::vector<BDDNode> variableCounter;
    
    /**
     * @brief This standardizes ambiguous ITE calls, that is, equivalence classes are created
     * whereby a representative is selected.
     */
    void standardize(BDDNode&, BDDNode&, BDDNode&, bool&);
    
    /**
     * @brief Swaps variables with each other, e. g. during standardization is required.
     * Furthermore, it forms the basis for many procedures regarding the determination of an optimal
     * variable order.
     */
    static void swap(BDDNode&, BDDNode&);
    
    /**
     * @brief Checks whether a terminal case exists during synthesis to terminate
     * the ITE algorithm early, so that performance is increased.
     */
    bool isTerminal(const BDDNode&, const BDDNode&, const BDDNode&, BDDNode&);
    
    /**
     * @brief Visualizes the individual nodes in the BDD or writes them formatted to a file.
     */
    void printNodeRecur(BDDNode&, std::ofstream&) const;
    
    /**
     * @brief Displays the variable graphically within a visualization.
     */
    std::string printIndex(BDDNode&) const;
public:
    /**
     * @brief This constructor instantiates the manager and reserves the memory for the
     * specified values with regard to variable support as well as unique and computed tables.
     */
    Manager(unsigned = 16, size_t = 5003, size_t = 5003);
    
    /**
     * @brief This destructor performs automatic garbage collection.
     */
    ~Manager();
    
    /**
     * @brief Cleans the memory for the tables and supported variables.
     */
    void clear();
    
    /**
     * @brief This method can be used to create variables or get the support to use them for nodes.
     */
    const BDDNode& createVariable(unsigned) const;
    
    /**
     * @brief Represents the core of the package to create BDDs by combining several BDDs.
     */
    BDDNode ite(BDDNode, BDDNode, BDDNode);
    
    /**
     * @brief Is directly related to the unique table and is called during synthesis to store
     * or search for nodes.
     */
    DDNode* findAdd(size_t, size_t, size_t);
    
    /**
     * @brief This method is called by exist (@see BDDNode#exist) and applies the existential
     * quantification to the given variable.
     */
    BDDNode existRecur(BDDNode&, unsigned);
    
    /**
     * @brief Nodes are displayed graphically, i. e. the BDD is represented in a file using
     * DOT (description language for graphs).
     */
    void printNode(BDDNode&, const std::string&, std::ofstream&) const;
    
    /**
     * @brief Displays information about the number of nodes and the time required for the synthesis.
     */
    void showInfo(const double, std::vector<BDDNode>&) const;
};
#endif
